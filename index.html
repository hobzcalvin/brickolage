<html>
<head>
  <script src="js/p5.js"></script>
  <script src="js/p5.dom.js"></script>
  <script src="js/opc.js"></script>

  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-touch-fullscreen" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <style type="text/css">
    body {
      background-color: black;
      color: white;
    }
    table {
      text-align: center;
    }
  </style>
</head>
<body>

<div id="uiDiv">
  <table>
    <tr>
      <td>
        Decay<br/>
        <input type="range" id="decaySlider" min="0" max="1000" value="800"/>
      </td>
      <!--
      <td>
        Base Hue<br/>
        <input type="range" id="diameterSlider" min="10" max="200" value="30"/>
      </td>
      <td>
        Base Saturation<br/>
        <input type="range" id="diameterSlider" min="10" max="200" value="30"/>
      </td>
      <td>
        Base Brightness<br/>
        <input type="range" id="diameterSlider" min="10" max="200" value="30"/>
      </td>
      <td>
        Palette:<br/>
      </td>
    </tr>
    <tr>
    -->
      <td>
        Width<br/>
        <input type="range" id="diameterSlider" min="10" max="200" value="30"/>
      </td>
      <!--
      <td>
        Hue Range<br/>
        <input type="range" id="diameterSlider" min="10" max="200" value="30"/>
      </td>
      <td>
        Saturation Range<br/>
        <input type="range" id="diameterSlider" min="10" max="200" value="30"/>
      </td>
      <td>
        Brightness Range<br/>
        <input type="range" id="diameterSlider" min="10" max="200" value="30"/>
      </td>
      -->
    </tr>
  </table>
  <span id="statusSpan"></span>
</div>
<div id="canvasDiv"></div>

<script>
/*
 For testing, do:
 /path/to/this-file> python -m SimpleHTTPServer 8000
 /path/to/websockify> ./websockify.py 7890 localhost:7891
 /path/to/openpixelcontrol> bin/gl_server -l layouts/mylayout.json -p 7891
 */

// Set true if using websockify, which expects a format slightly different
// from the fcserver
var WEBSOCKIFY = true;
var OPC_HOST = window.location.hostname + ':7890';

var HEIGHT = 10;
var WIDTH = 40;
// Milliseconds of inactivity before simulating activity
var INACTIVITY_TIMEOUT = 5000;
var COLOR_SPEED = 5000;

var lastFrame;
var lastTouch;

var decaySlider;
var diameterSlider;
var statusSpan;


function setup() {
  opc = new p5.OPC(OPC_HOST, WEBSOCKIFY);
  pixelDensity(1);
  var canvas = createCanvas(windowWidth, windowHeight);
  canvas.parent('#canvasDiv');
  // Do this now so we have it for draw() which is called by resizeCanvas()
  lastFrame = get();

  colorMode(HSB, COLOR_SPEED, 1, 1);
  fill(0, 0, 1);

  decaySlider = select('#decaySlider');
  diameterSlider = select('#diameterSlider');
  statusSpan = select('#statusSpan');

  // This encompasses all post-resize setup logic, so always call it to start
  windowResized();
  lastTouch = millis();
}
function windowResized() {
  var thediv = select('#uiDiv');
  resizeCanvas(windowWidth, windowHeight - thediv.size().height);
  setupGrid();
}
function setupGrid() {
  for (var i = 0; i < 8; i++) {
    opc.ledGrid(i*50, HEIGHT, 5, width * (0.5 + i) / 8, height/2, width/WIDTH, width/WIDTH, 3*Math.PI/2, true, true);
  }
  background(0);
  lastFrame = get();
}
function keyPressed() {
  if (keyCode === ESCAPE) {
    opc.toggleConnection();
  }
}
function deviceShaken() {
  opc.toggleConnection();
}

// Object holding new touches that need to be drawn
var touchHistory = {};
// Store of old touches that we'll use if there's inactivity
var touchArchive = [];
// Which index in touchArchive is next
var replayCursor = 0;
// Current touch in touchArchive that we're currently replaying
var currentReplay = null;
// Another boolean to track if we're entering replay right now
var inReplay = false;

function newColor() {
  return color(millis() % COLOR_SPEED, 1, 1);
}
function randomizeSlider(s) {
  var min = s.attribute('min');
  s.value(Math.random() * (s.attribute('max')-min) + min);
}

function draw() {
  // This points to touchHistory when there's active use; otherwise it holds
  // simulated touches from the touchArchive.
  var touchStore = {};
  if (lastTouch < millis() - INACTIVITY_TIMEOUT) {
    if (!inReplay) {
      inReplay = true;
      // This is a new replay sequence. Randomize decay.
      randomizeSlider(decaySlider);
    }
    // We're inactive. If there's no touch currently being replayed and
    // the touchArchive has touches to replay, pick the next one.
    if (!currentReplay && touchArchive.length > 0) {
      // Make sure we pick a reasonable index.
      replayCursor %= touchArchive.length;
      // We'll pick the next index next time.
      currentReplay = touchArchive[replayCursor++];

      // Pick a random size for this touch in replay
      randomizeSlider(diameterSlider);

      // Earliest point in the touch has color data, etc.
      var earliest = currentReplay[currentReplay.length-1];
      // Count replays starting from 0
      earliest.replayCount = earliest.replayCount + 1 || 0;
      // Give it a new random color
      earliest.color = newColor();
      // All timestamps will be subtracted by this for proper replay timing
      var t_offset = earliest.t - millis();
      for (var i in currentReplay) {
        var point = currentReplay[i];
        point.t -= t_offset;
        // Forget these, if any
        delete point.drawn;
        delete point.pendingDelete;
        // Alternate mirroring vertical and horizontal. Gets all 4 reflections.
        if (earliest.replayCount % 2) {
          point.x = width - point.x;
        } else {
          point.y = height - point.y;
        }
      }
    }
    if (currentReplay) {
      // We're in the middle of a replay. Has the last point been drawn?
      if (currentReplay[0].drawn) {
        // Yes; the replay of this touch is over. Pick a new one next time.
        currentReplay = null;
      } else {
        // Still more points in the current replayed touch. Transform this
        // into the faked touchStore (acts like touchHistory) by filtering out
        // all points in the "future" (now that we've offset the timestamps)
        touchStore = {
          0: currentReplay.filter(function(pt) { return pt.t <= millis() })
        };
      }
    }
  } else {
    // Someone's playing! So use the real touchHistory, and forget about
    // whatever we were replaying.
    touchStore = touchHistory;
    currentReplay = null;
    inReplay = false;
  }

  var dia = diameterSlider.value();
  strokeWeight(dia);
  tint(0, 0, Math.pow(decaySlider.value() / 1000.0, 1/8));
  // Tint is applied so this will fade the image slowly
  image(lastFrame);

  // Loop through all still-going touches 
  for (var i in touchStore) {
    var touch = touchStore[i];
    // If this touch has multiple points in its path,
    if (touch.length > 1 &&
        // and the latest point has never been drawn,
        !touch[0].drawn) {
      // then draw a line from the latest point to the one before.
      // Color is stored in the earliest history element.
      stroke(touch[touch.length-1].color);
      for (var j = 0; j < touch.length-1; j++) {
        if (!touch[j].drawn) {
          line(touch[j].x, touch[j].y, touch[j+1].x, touch[j+1].y);
          touch[j].drawn = true;
        } else {
          // If this point has been drawn, all previous ones must have been too
          break;
        }
      }
    // Otherwise (only one point, or the last point has been drawn),
    // just draw the latest point as a circle. This means continued
    // touching means continued drawing of the circle.
    } else {
      noStroke();
      // Color is stored in the earliest history element.
      fill(touch[touch.length-1].color);
      ellipse(touch[0].x, touch[0].y, dia, dia);
      touch[0].drawn = true;
    }
    if (touch[0].pendingDelete) {
      // This touch has already ended, but it was kept in touchStore (actually,
      // this must be touchHistory in practice) so we
      // could draw it. Now we should delete it.
      delete touchStore[i];
    }
  } 

  // Save the canvas before OPC does crap to it
  lastFrame = get();
  opc.handleDraw();
  statusSpan.html(opc.getState() + ' | fps:' + Math.round(frameRate()));
}

// One-stop function to handle the current state of touches, which if this is
// called, probably changed in some way.
function handleTouches(ts) {
  lastTouch = millis();
  // Build a new touchHistory array while we delete entries from the old one
  newTH = {};
  for (var i in ts) {
    var touch = ts[i];
    if (touch.x < 0 || touch.x > width || touch.y < 0 || touch.y > height) {
      // Ignore this touch; it's outside the canvas bounds
      continue;
    }
    var record = { t: lastTouch, x: touch.x, y: touch.y };
    if (touch.id in touchHistory) {
      newTH[touch.id] = [record].concat(touchHistory[touch.id]);
      // Remove this touch from old touchHistory; we've seen it.
      delete touchHistory[touch.id];
    } else {
      record.color = newColor();
      newTH[touch.id] = [record]
    }
  }
  // Any remaining touches in touchHistory are now over.
  // However, they may not all have been drawn, meaning they haven't
  // been drawn to the canvas.
  for (var i in touchHistory) {
    if (!touchHistory[i][0].drawn) {
      // Touch still has some drawing left, so keep it in touchHistory but
      // with a flag so draw() knows it can delete it when drawn.
      touchHistory[i][0].pendingDelete = true;
      // Now that this touch is over, its id may be reused (probably only
      // happens for mouse events). So give it a hacky new id.
      newTH[i+'pending'] = touchHistory[i];
    }
    // This touch is technically over, so move it to the history for replay
    touchArchive.push(touchHistory[i]);
  }
  touchHistory = newTH;
}
// Pressed and tragged are the same thing: update with a faked touches object
mousePressed = mouseDragged = function() {
  handleTouches([{x: mouseX, y: mouseY, id:0}]);
}
// Mouse released means no more (faked) touches
mouseReleased = function() {
  handleTouches([]);
}
// Real touch events can just pass along the touches array
touchStarted = touchMoved = touchEnded = function() {
  handleTouches(touches);
}


// Prevent overscrolling on iOS etc.
document.body.addEventListener('touchmove', function(event) {
  // We need the touchmove event for sliders to work properly
  if (event.target.nodeName != "INPUT") {
    event.preventDefault();
  }
}, false); 

</script>
</body>
</html>
